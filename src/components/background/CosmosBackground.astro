---
interface Props {
	id?: string;
}

const { id = 'cosmos-background' } = Astro.props;
---

<canvas id={id} class="cosmos-background" />

<style>
	.cosmos-background {
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: -1;
		pointer-events: none;
	}
</style>

<script is:inline>
	(function() {
		const canvasId = id;
		const canvas = document.getElementById(canvasId);
		if (!canvas) return;
		
		const ctx = canvas.getContext('2d');
		let width, height;
		let particles = [];
		let mouse = { x: null, y: null, active: false };
		let time = 0;
		
		const config = {
			particleCount: 50,
			connectionDistance: 180,
			mouseConnectionDistance: 250,
			orbMinSize: 8,
			orbMaxSize: 35,
			sparkleCount: 80
		};
		
		const colors = [
			'#fbb034', '#ffffff', '#ffd700', '#ff8c00', '#fff8dc',
			'rgba(251, 176, 52, 0.6)', 'rgba(255, 255, 255, 0.8)'
		];
		
		function resize() {
			width = canvas.width = window.innerWidth;
			height = canvas.height = window.innerHeight;
		}
		
		function randomColor() {
			return colors[Math.floor(Math.random() * colors.length)];
		}
		
		function random(min, max) {
			return Math.random() * (max - min) + min;
		}
		
		class Orb {
			constructor() {
				this.reset();
			}
			
			reset() {
				this.x = Math.random() * width;
				this.y = Math.random() * height;
				this.size = random(config.orbMinSize, config.orbMaxSize);
				this.baseSize = this.size;
				this.color = randomColor();
				this.speedX = random(-0.4, 0.4);
				this.speedY = random(-0.4, 0.4);
				this.opacity = random(0.3, 0.7);
				this.pulseSpeed = random(0.01, 0.03);
				this.pulseOffset = Math.random() * Math.PI * 2;
				this.glowSize = this.size * random(2, 4);
			}
			
			draw() {
				const pulse = Math.sin(time * this.pulseSpeed + this.pulseOffset) * 0.3 + 1;
				const currentSize = this.baseSize * pulse;
				
				const gradient = ctx.createRadialGradient(
					this.x, this.y, 0,
					this.x, this.y, currentSize * this.glowSize
				);
				
				if (this.color.startsWith('rgba')) {
					gradient.addColorStop(0, this.color);
					gradient.addColorStop(0.4, this.color.replace(/[\d.]+\)$/, '0.3)'));
					gradient.addColorStop(1, 'transparent');
				} else {
					gradient.addColorStop(0, this.color);
					gradient.addColorStop(0.2, this.color + 'cc');
					gradient.addColorStop(0.5, this.color + '66');
					gradient.addColorStop(1, 'transparent');
				}
				
				ctx.beginPath();
				ctx.arc(this.x, this.y, currentSize * this.glowSize, 0, Math.PI * 2);
				ctx.fillStyle = gradient;
				ctx.fill();
				
				ctx.beginPath();
				ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
				ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
				ctx.fill();
				
				ctx.beginPath();
				ctx.arc(this.x - currentSize * 0.3, this.y - currentSize * 0.3, currentSize * 0.2, 0, Math.PI * 2);
				ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
				ctx.fill();
			}
			
			update() {
				this.x += this.speedX;
				this.y += this.speedY;
				
				if (this.x < -this.size * this.glowSize) this.x = width + this.size;
				if (this.x > width + this.size * this.glowSize) this.x = -this.size;
				if (this.y < -this.size * this.glowSize) this.y = height + this.size;
				if (this.y > height + this.size * this.glowSize) this.y = -this.size;
				
				if (mouse.active) {
					const dx = mouse.x - this.x;
					const dy = mouse.y - this.y;
					const distance = Math.sqrt(dx * dx + dy * dy);
					const maxDistance = 200;
					
					if (distance < maxDistance) {
						const force = (maxDistance - distance) / maxDistance;
						const angle = Math.atan2(dy, dx);
						this.speedX -= Math.cos(angle) * force * 0.1;
						this.speedY -= Math.sin(angle) * force * 0.1;
					}
				}
				
				const speed = Math.sqrt(this.speedX * this.speedX + this.speedY * this.speedY);
				if (speed > 1.5) {
					this.speedX = (this.speedX / speed) * 1.5;
					this.speedY = (this.speedY / speed) * 1.5;
				}
			}
		}
		
		class Sparkle {
			constructor() {
				this.reset();
			}
			
			reset() {
				this.x = Math.random() * width;
				this.y = Math.random() * height;
				this.size = random(0.5, 2.5);
				this.color = randomColor();
				this.twinkleSpeed = random(0.02, 0.08);
				this.twinkleOffset = Math.random() * Math.PI * 2;
				this.alpha = 0;
				this.maxAlpha = random(0.5, 1);
			}
			
			draw() {
				const twinkle = Math.sin(time * this.twinkleSpeed + this.twinkleOffset);
				this.alpha = ((twinkle + 1) / 2) * this.maxAlpha;
				
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
				if (this.color.startsWith('#')) {
					const r = parseInt(this.color.slice(1, 3), 16);
					const g = parseInt(this.color.slice(3, 5), 16);
					const b = parseInt(this.color.slice(5, 7), 16);
					ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${this.alpha})`;
				} else {
					ctx.fillStyle = this.color.replace(')', `, ${this.alpha})`);
				}
				ctx.fill();
			}
		}
		
		class Diamond {
			constructor() {
				this.reset();
			}
			
			reset() {
				this.x = Math.random() * width;
				this.y = Math.random() * height;
				this.size = random(4, 12);
				this.rotation = Math.random() * Math.PI * 2;
				this.rotationSpeed = random(-0.01, 0.01);
				this.color = randomColor();
				this.speedX = random(-0.2, 0.2);
				this.speedY = random(-0.2, 0.2);
				this.opacity = random(0.2, 0.5);
			}
			
			draw() {
				ctx.save();
				ctx.translate(this.x, this.y);
				ctx.rotate(this.rotation + time * this.rotationSpeed);
				
				ctx.beginPath();
				ctx.moveTo(0, -this.size);
				ctx.lineTo(this.size, 0);
				ctx.lineTo(0, this.size);
				ctx.lineTo(-this.size, 0);
				ctx.closePath();
				
				if (this.color.startsWith('#')) {
					const r = parseInt(this.color.slice(1, 3), 16);
					const g = parseInt(this.color.slice(3, 5), 16);
					const b = parseInt(this.color.slice(5, 7), 16);
					ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${this.opacity})`;
				} else {
					ctx.fillStyle = this.color.replace(')', `, ${this.opacity})`);
				}
				ctx.fill();
				ctx.restore();
			}
			
			update() {
				this.x += this.speedX;
				this.y += this.speedY;
				
				if (this.x < -20) this.x = width + 20;
				if (this.x > width + 20) this.x = -20;
				if (this.y < -20) this.y = height + 20;
				if (this.y > height + 20) this.y = -20;
			}
		}
		
		function init() {
			resize();
			particles = [];
			
			for (let i = 0; i < 15; i++) {
				particles.push(new Orb());
			}
			
			for (let i = 0; i < config.sparkleCount; i++) {
				particles.push(new Sparkle());
			}
			
			for (let i = 0; i < 8; i++) {
				particles.push(new Diamond());
			}
		}
		
		function drawConnections() {
			const orbs = particles.filter(p => p instanceof Orb);
			
			for (let i = 0; i < orbs.length; i++) {
				for (let j = i + 1; j < orbs.length; j++) {
					const dx = orbs[i].x - orbs[j].x;
					const dy = orbs[i].y - orbs[j].y;
					const distance = Math.sqrt(dx * dx + dy * dy);
					
					if (distance < config.connectionDistance) {
						const opacity = (1 - distance / config.connectionDistance) * 0.3;
						ctx.beginPath();
						ctx.moveTo(orbs[i].x, orbs[i].y);
						ctx.lineTo(orbs[j].x, orbs[j].y);
						ctx.strokeStyle = `rgba(251, 176, 52, ${opacity})`;
						ctx.lineWidth = 1;
						ctx.stroke();
					}
				}
				
				if (mouse.active) {
					const dx = orbs[i].x - mouse.x;
					const dy = orbs[i].y - mouse.y;
					const distance = Math.sqrt(dx * dx + dy * dy);
					
					if (distance < config.mouseConnectionDistance) {
						const opacity = (1 - distance / config.mouseConnectionDistance) * 0.5;
						ctx.beginPath();
						ctx.moveTo(orbs[i].x, orbs[i].y);
						ctx.lineTo(mouse.x, mouse.y);
						ctx.strokeStyle = `rgba(251, 176, 52, ${opacity})`;
						ctx.lineWidth = 1.5;
						ctx.stroke();
					}
				}
			}
		}
		
		function animate() {
			ctx.clearRect(0, 0, width, height);
			time++;
			
			const bgGradient = ctx.createRadialGradient(
				width / 2, height / 2, 0,
				width / 2, height / 2, Math.max(width, height) / 2
			);
			bgGradient.addColorStop(0, 'rgba(15, 20, 25, 0.1)');
			bgGradient.addColorStop(1, 'transparent');
			ctx.fillStyle = bgGradient;
			ctx.fillRect(0, 0, width, height);
			
			drawConnections();
			
			particles.forEach(p => {
				if (p.update) p.update();
				p.draw();
			});
			
			requestAnimationFrame(animate);
		}
		
		window.addEventListener('resize', resize);
		
		canvas.addEventListener('mousemove', (e) => {
			mouse.x = e.clientX;
			mouse.y = e.clientY;
			mouse.active = true;
		});
		
		canvas.addEventListener('mouseleave', () => {
			mouse.active = false;
		});
		
		canvas.addEventListener('click', (e) => {
			const orbs = particles.filter(p => p instanceof Orb);
			orbs.forEach(orb => {
				const dx = orb.x - e.clientX;
				const dy = orb.y - e.clientY;
				const distance = Math.sqrt(dx * dx + dy * dy);
				if (distance < 300) {
					const force = (300 - distance) / 300;
					orb.speedX += (dx / distance) * force * 2;
					orb.speedY += (dy / distance) * force * 2;
				}
			});
		});
		
		init();
		animate();
	})();
</script>
